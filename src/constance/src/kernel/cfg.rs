//! Static configuration mechanism for the kernel
use core::marker::PhantomData;

use super::{task, Port};
use crate::utils::Init;

mod vec;
#[doc(hidden)]
pub use self::vec::ComptimeVec;

/// Define a configuration function.
///
/// The following macros are available inside the function:
///
/// # `call!(expr, arg1, arg2, ...)`
///
/// Invokes another configuration function `expr`.
///
/// # `build!(expr, name1 = arg1, name2 = arg2, ...)`
///
/// Invokes a builder method `expr`, calls modifying methods `name1, name2, ...`
/// on the builder, and then finally calls `finish`, which is assumed to be a
/// configuration function.
///
/// # `new_task!()`
///
/// Defines a task.
///
/// # `new_hunk!(T)`
///
/// Defines a new hunk. `T` must implement [`Init`](crate::utils::Init).
#[macro_export]
macro_rules! configure {
    (
        [$dollar:tt]
        $( #[$meta:meta] )*
        $vis:vis fn $ident:ident(_: CfgBuilder<$sys:ty>) -> $id_map:ty {
            $($tt:tt)*
        }
    ) => {
        // FIXME: `&mut` in `const fn` <https://github.com/rust-lang/rust/issues/57349>
        //        is not implemented yet. Receiving `CfgBuilder` by `&mut _`
        //        would be more cleaner
        $( #[$meta] )*
        #[allow(unused_macros)]
        $vis const fn $ident(
            cfg: $crate::kernel::CfgBuilder<$sys>
        ) -> $crate::kernel::CfgOutput<$sys, $id_map> {
            #[allow(unused_mut)]
            let mut cfg = cfg;

            macro_rules! call {
                ($path:expr $dollar(, $arg:expr)* $dollar(,)*) => {{
                    use $crate::kernel::CfgOutput;

                    let CfgOutput { cfg: new_cfg, id_map } = $path(cfg, $dollar($arg),*);
                    cfg = new_cfg;
                    id_map
                }};
            }

            macro_rules! build {
                ($path:expr $dollar(, $argname:ident = $arg:expr)* $dollar(,)*) => {{
                    let builder = $path $dollar(. $argname($arg))*;

                    let CfgOutput { cfg: new_cfg, id_map } = builder.finish(cfg, $dollar($arg),*);
                    cfg = new_cfg;
                    id_map
                }};
            }

            macro_rules! new_task {
                () => {{
                    use ::core::num::NonZeroUsize;
                    use $crate::kernel::Task;

                    cfg.tasks = cfg.tasks.push($crate::kernel::CfgBuilderTask {});
                    unsafe {
                        Task::from_id(NonZeroUsize::new_unchecked(cfg.tasks.len()))
                    }
                }};
            }

            // TODO: array hunk
            macro_rules! new_hunk {
                ($ty:ty) => {{
                    use ::core::mem;
                    use $crate::{kernel::{Hunk, HunkInitAttr}, utils::Init};

                    let align = mem::align_of::<$ty>();
                    let size = mem::size_of::<$ty>();

                    // Round up `hunk_pool_len`
                    cfg.hunk_pool_len = (cfg.hunk_pool_len + align - 1) / align * align;

                    let start = cfg.hunk_pool_len;

                    cfg.hunks = cfg.hunks.push(HunkInitAttr {
                        offset: start,
                        init: |dest| unsafe {
                            *(dest as *mut _) = <$ty as Init>::INIT;
                        },
                    });

                    cfg.hunk_pool_len += size;

                    unsafe {
                        Hunk::from_range(start, size)
                    }
                }};
            }

            // `$ctx` will be updated by the code generated by `call!`

            let id_map = {
                $($tt)*
            };

            $crate::kernel::CfgOutput { cfg, id_map }
        }
    };

    (
        [$dollar:tt]
        $($tt:tt)*
    ) => {
        compile_error!("invalid syntax")
    };

    ($($tt:tt)*) => {
        $crate::configure! {
            [$]
            $($tt)*
        }
    };
}

/// Attach a configuration function (defined by [`configure!`]) to a "system"
/// type.
#[macro_export]
macro_rules! build {
    ($sys:ty, $configure:expr) => {{
        use $crate::{
            kernel::{CfgBuilder, HunkAttr, HunkInitAttr, KernelCfg, Port, TaskAttr, TaskState},
            utils::AssertSendSync,
        };

        // `$configure` produces two values: a `CfgBuilder` and an ID map
        // (custom type). We need the first one to be `const` so that we can
        // calculate the values of generic parameters based on its contents.
        const CFG: CfgBuilder<$sys> = $configure(CfgBuilder::new()).cfg;

        // The second value can be just `let`
        let id_map = $configure(CfgBuilder::new()).id_map;

        $crate::array_item_from_fn! {
            const TASK_STATE:
                [TaskState<<$sys as Port>::PortTaskState>; _] =
                    (0..CFG.tasks.len()).map(|i| CFG.tasks.get(i).to_state());
            const TASK_ATTR: [TaskAttr; _] =
                (0..CFG.tasks.len()).map(|i| CFG.tasks.get(i).to_attr());
        }

        static HUNK_POOL: AssertSendSync<::core::cell::UnsafeCell<[u8; { CFG.hunk_pool_len }]>> =
            AssertSendSync(::core::cell::UnsafeCell::new([0; CFG.hunk_pool_len]));
        const HUNK_INITS: [HunkInitAttr; { CFG.hunks.len() }] = CFG.hunks.to_array();

        // Safety: We are `build!`, so it's okay to `impl` this
        unsafe impl KernelCfg for $sys {
            const HUNK_ATTR: HunkAttr = HunkAttr {
                hunk_pool: || &HUNK_POOL.0,
                inits: &HUNK_INITS,
            };

            const TASK_STATE: &'static [TaskState<<$sys as Port>::PortTaskState>] = &TASK_STATE;
            const TASK_ATTR: &'static [TaskAttr] = &TASK_ATTR;
        }

        id_map
    }};
}

#[macro_export]
#[doc(hidden)]
macro_rules! array_item_from_fn {
    ($(
        $static_or_const:tt $out:ident: [$ty:ty; _] = (0..$len:expr).map(|$var:ident| $map:expr);
    )*) => {$(
        $static_or_const $out: [$ty; { $len }] = {
            let mut values = [$crate::prelude::Init::INIT; { $len }];
            let mut i = 0;
            while i < values.len() {
                values[i] = {
                    let $var = i;
                    $map
                };
                i += 1;
            }
            values
        };
    )*};
}

// The "real" public interface ends here
// ---------------------------------------------------------------------------

#[doc(hidden)]
pub struct CfgBuilder<System> {
    _phantom: PhantomData<System>,
    pub hunks: ComptimeVec<super::HunkInitAttr>,
    pub hunk_pool_len: usize,
    pub tasks: ComptimeVec<CfgBuilderTask>,
}

impl<System> CfgBuilder<System> {
    pub const fn new() -> Self {
        Self {
            _phantom: PhantomData,
            hunks: ComptimeVec::new(),
            hunk_pool_len: 0,
            tasks: ComptimeVec::new(),
        }
    }
}

/// Output of [a configuration function].
///
/// In a configuration function, use `call!` or `build!` to call other
/// configuration functions (i.e., the functions returning this type).
///
/// [a configuration function]: configure
pub struct CfgOutput<System, T> {
    #[doc(hidden)]
    pub cfg: CfgBuilder<System>,

    #[doc(hidden)]
    pub id_map: T,
}

#[doc(hidden)]
#[derive(Debug, Clone, Copy)]
pub struct CfgBuilderTask {}

impl CfgBuilderTask {
    pub const fn to_state<PortTaskState: Init>(&self) -> task::TaskState<PortTaskState> {
        task::TaskState {
            port_task_state: PortTaskState::INIT,
        }
    }

    pub const fn to_attr(&self) -> task::TaskAttr {
        task::TaskAttr {}
    }
}

/// Associates "system" types with kernel-private data. Use [`build!`] to
/// implement.
///
/// # Safety
///
/// This is only intended to be implemented by `build!`.
pub unsafe trait KernelCfg: Port {
    #[doc(hidden)]
    const HUNK_ATTR: super::HunkAttr;

    #[doc(hidden)]
    const TASK_STATE: &'static [task::TaskState<Self::PortTaskState>];

    #[doc(hidden)]
    const TASK_ATTR: &'static [task::TaskAttr];
}
