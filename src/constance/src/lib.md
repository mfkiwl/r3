The Constance RTOS

[![Constance and Fluttershy](https://derpicdn.net/img/2018/5/25/1740985/medium.png)](http://derpibooru.org/1740985)

# Design

## Trait-based Composition

The Constance RTOS utilizes Rust's trait system to allow system designers to construct a system in a modular way.

The following pseudocode outlines the traits and types involved in hooking up the kernel, port, and application to each other.

```rust,ignore
crate constance {
    /// Associates `System` with kernel-private data. Implemented by `build!`.
    /// The kernel-private data includes port-specific types.
    unsafe trait KernelCfg1 {
        /* ... */
    }

    /// Implemented by a port.
    unsafe trait Port: KernelCfg1 {
        type TaskState;
        fn dispatch();
        /* ... */
    }

    /// Associates `System` with kernel-private data. Implemented by `build!`.
    /// The kernel-private data includes port-specific types.
    unsafe trait KernelCfg2: Port {
        const TASK_CFG: &'static [TaskCfg<Self::TaskState>];
        /* ... */
    }

    /// The API used by the application and the port. This is automatically
    /// implemented when a type has sufficient trait `impl`s.
    trait Kernel: Port + KernelCfg2 {}

    impl<T: Port + KernelCfg1 + KernelCfg2> Kernel for T { /* ... */ }

    /// Instantiate the `static`s necessary for the kernel's operation. This is
    /// absolutely impossible to do with blanket `impl`s.
    macro_rules! build {
        ($sys:ty, $configure:expr) => {
            unsafe impl $crate::KernelCfg1 for $sys {}
            unsafe impl $crate::KernelCfg2 for $sys {
                const TASK_CFG: &'static [TaskCfg<Self::TaskState>] = /* ... */;
                /* ... */
            }
        };
    }
}

crate constance_xxx_port {
    // The following approach doesn't work because of a circular dependency in
    // blanket `impl`s:
    //
    // impl<T: constance::Kernel> constance::Port for T {}

    // Instead, `Port` should be implemented specifically for a type. This is
    // facilitated by a macro, which also has an advantage of giving the port an
    // opportunity to insert port-specific code (such as `static`s and inline
    // assembler) referencing `$sys` to the application.
    macro_rules! use_port {
        (unsafe struct $sys:ident) => {
            struct $sys;

            // Assume `$sys: Kernel`
            unsafe impl constance::Port for $sys {
                /* ... */
            }
        };
    }
}

crate your_app {
    constance_xxx_port::use_port!(unsafe struct System);

    struct Objects {
        task1: constance::Task<System>,
    }

    static COTTAGE: Objects = constance::build!(System, configure_app);

    // The configuration function. See "Static Configuration" for details.
    fn configure_app(b: &mut constance::CfgBuilder<System>) -> Objects {
        Objects { task1: /* ... */ }
    }
}
```

## Static Configuration

Kernel objects are created in *a configuration function* having the signature `const fn (&mut `[`CfgBuilder`]`) -> T` (+ optional `self` and extra parameters). The code generated by [`build!`] calls *a top-level configuration function* (at compile time) to collect information such as a set of kernel objects that need to be instantiated. This information is used to implement [`KernelCfg1`] and [`KernelCfg2`] on a given system type. At the same time, this process also produces handles to the defined kernel objects (such as [`Task`]), which can be returned from a configuration function directly or packaged in a user-defined container type. `build!` returns the evaluation result of the top-level configuration function. By storing this in a `const` variable, application code can access the defined kernel objects.

[`CfgBuilder`]: crate::kernel::cfg::CfgBuilder
[`KernelCfg1`]: crate::kernel::KernelCfg1
[`KernelCfg2`]: crate::kernel::KernelCfg2
[`Task`]: crate::kernel::Task

Configuration functions can call other configuration functions. This is useful to attribute a certain semantics to a group of kernel objects, making them behave in a meaningful way as a whole, and expose a whole new, higher-level interface. For example, a mutex object similar to `std::sync::Mutex` can be created by combining a low-level mutex object (not implemented yet) and a [`Hunk`]`<System, UnsafeCell<T>>`.

[`Hunk`]: crate::kernel::Hunk

The constructors of kernel objects are configuration functions by themselves, but they are different from normal configuration functions in that they can actually mutate the contents of `CfgBuilder` (which `build!` will use to create kernel structures in the final form), ultimately shaping the outcome of the configuration process. Therefore, they are the smallest building blocks of configuration functions.

It's possible to write a configuration function directly. However, [`configure!`] can make this process easier by providing macros that offer more concise syntaxes for common patterns.
